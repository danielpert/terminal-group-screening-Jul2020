'''
Update the oplsaa.xml file with new atomtypes and bonded and nonbonded
potential energy parameters (from the OPLS all atom forcefield)
from an xml file generated by LigParGen and the SMILES string used
to create the file. It is VERY important that the SMILES string is exactly
the same as the string used to generate the XML file in order to ensure
consistent indexing of the atoms in the molecule.

http://traken.chem.yale.edu/ligpargen/index.html

Note that the SMARTS definitons and atom descriptions must be added
manually. This can be done by using the 'residues' section of the
input xml file to create a drawing of the molecule with the atoms labeled by their atom
type number, in order to see which id is which atom, and then adding the
SMARTS definitions and descriptions.

Usage: python update_oplsaa.py -s <SMILES string of molecule> -a <path to xml file to add> -t <path to xml file to add to>
       python update_oplsaa.py --smiles <SMILES string of molecule> --add <path to xml file to add> --to <path to xml file to add to>

'''
# Still needs to be done:
#     automatically add overrides
#     automatically add correct indentation

# import relevent packages
import sys
import argparse
import numpy as np
import xml.etree.ElementTree as ET
from itertools import groupby
import signac
import pathlib
import mbuild as mb
import foyer


def find_atomtypes(smiles_str, forcefield):
    '''
    Given a SMILES string, find the atoms in the
    molecule that are already atomtyped, and
    find their atomtype in the oplsaa.xml file.
    Those not atomtyped are assigned 'opls_1010'

    Parameters
    ----------
    smiles_str : str
        SMILES string that was
        used to create XML file that
        is being added as the --add
        parameter
    forcefield : foyer.forcefield.Forcefield
        forcefield to apply to
        molecule to check atomtyping

    Returns
    ----------
    types : dict
        map from atom index to atomtype
        'oplsa_1010' if no type
    '''
    mbuild_structure = mb.load(smiles_str, smiles = True)
    parmed_structure = mbuild_structure.to_parmed()
    typed_surface = forcefield.apply(parmed_structure,verbose=False,assert_bond_params=False,assert_angle_params=False,
                                assert_improper_params=False,assert_dihedral_params=False)
    types = dict()
    for i,atom in enumerate(list(typed_surface.atoms)):
        types[i] = atom.type
    return types


def fourier_coefs_to_RB_coefs(f1, f2, f3, f4):
    '''
    Convert fourier coefficients in periodic proper
    dihedral potential equation to Ryckaert-Bellemans
    parameters C0-C5
    
    Paramters
    ----------
    f1, f2, f3, f4 : float
        fourier coefficients 1 thru 4
    
    Returns
    ----------
    c0, c1, c2, c3, c4, c5 : float
        Ryckaert-Belleman parameters C1-C5
    '''
    c0 = f2 + (f1 + f3)/2.0
    c1 = (3*f3 - f1)/2.0
    c2 = 4*f4 - f2
    c3 = -2*f3
    c4 = -4*f4
    c5 = 0.0
    return (c0, c1, c2, c3, c4, c5)


def split_classname(classname):
    '''
    Splits a classname, i.e. 'H805'
    or 'Si1010' into its element
    and its type id
    
    Parameters
    ----------
    classname : str
        classname of atom type
        i.e. 'H805'
    Returns
    ----------
    element : str
        element symbol
        i.e. 'H'
    typeid : int
        number after element symbol
        i.e. 805
        
    '''
    element = ''
    for isalpha, grouper in groupby(classname, str.isalpha):
        if isalpha and not element:
            element = ''.join(grouper)
        elif not isalpha:
            typeid = int(''.join(grouper))
    return element, typeid


def update_classnums(root, opls_root, parent_name, child_name, mapping):
    '''
    Given the root of an ElementTree, the name of a
    parent Element, and the name of the child Elements
    to modify:
    
    1) apply a mapping to remove child Elements containing
       the atoms whose IDs map to -1 in the 'mapping' dictionary.
    2) reset the 'class' attributes representing the atoms to
       reflect the new indexing based on the 'mapping' dictionary.
       
    Returns nothing, but rather directly modifies the element tree
    passed in.
    
    Parameters
    ----------
    root : xml.etree.ElementTree.Element
        root element of the ElementTree to be modified
    opls_root : xml.etree.ElementTree.Element
        root element of ElementTree of XML file being
        added to (oplsaa.xml file)
    parent_name : str
        parent element of the elements
        to be altered, i.e. "HarmonicBondForce"
    child_name : str
        child elements to be updated, i.e. "Bond"
    mapping : dict
        mapping from old index to index after
        extra hydrogens are removed, or maps
        to -1 if old index is to be removed
    '''
    parent = root.find(parent_name)
    children = parent.findall(child_name)
    children_to_remove = []
    
    for child in children:
        attr2change = [attr for attr in child.attrib.keys() \
            if (('class' in attr) or ('type' in attr) or ('name' in attr))]
        
        for attr in attr2change:
            if (('type' in attr) or ('name' in attr)):
                index = int(child.get(attr).split('_')[-1])
            else:
                element, index = split_classname(child.get(attr))
            new_index = mapping[index]
            if new_index == -1:
                children_to_remove.append(child)
                break
            if (('type' in attr) or ('name' in attr)):
                child.set(attr, 'opls_{}'.format(new_index))
            elif parent_name == 'AtomTypes':
                child.set(attr, element + str(new_index))
            else:
                child.set(attr, find_class(root1=opls_root,
                                           root2=root,
                                           name_index=new_index))
    for ch in children_to_remove:
        parent.remove(ch)
    return


def find_class(root1, root2, name_index):
    '''
    Convert the name index of an atomtype to
    the class symbol
    
    Parameters
    ----------
    root1, root2 : xml.etree.ElementTree.Element
        root elements of XML ElementTrees to search
        thru to find atomtype with `name_index`
    name_index : int
        the index of the atom type, i.e. 136 if
        the name is 'opls_136'
        
    Returns
    ----------
    class : str
        the class symbol of the atom type being
        queried, i.e. 'CT'
        
    '''
    try:
        atom_types = root1.find('AtomTypes')
        node = atom_types.findall("./Type[@name='opls_{}']".format(name_index))[0]
    except IndexError:
        atom_types = root2.find('AtomTypes')
        node = atom_types.findall("./Type[@name='opls_{}']".format(name_index))[0]
    return node.get('class')


def find_idx(root, cls):
    '''
    Convert class symbol to name index
    reverse of find_class
    
    Parameters
    ----------
    root : xml.etree.ElementTree.Element
        root element of XML ElementTree to search
        thru to find atomtype with `cls`
    cls : str
        class symbol of atom type
        
    Returns
    ----------
    name_index : int
        index of atom type
        
    '''
    atom_types = root.find('AtomTypes')
    node = atom_types.findall("./Type[@class='{}']".format(cls))[0]
    name = node.get('name')
    name_index = int(name.split('_')[-1])
    return name_index
    
    
def remove_duplicates(root, opls_root, parent_name, child_name, next_idx):
    '''
    Remove bonded parameters from force field that have the same
    atomtypes as another bonded parameter, or if none of the atom
    types are new atomtypes. If the atomtype index is less than
    next_idx, it is assumed to be an already existing type.

    Returns nothing, but rather directly modifies the element tree
    passed in.

    Parameters
    ----------
    root : xml.etree.ElementTree.Element
        root element of the ElementTree to be modified
    opls_root : xml.etree.ElementTree.Element
        root element of the ElementTree to add to
    parent_name : str
        parent element of the elements
        to be altered, i.e. "HarmonicBondForce"
    child_name : str
        child elements to be updated, i.e. "Bond"
    next_idx : int
        the next index to be added to oplsaa.xml
        (or whatever file is being appended to)
    '''
    parent = root.find(parent_name)
    children = parent.findall(child_name)
    children_to_remove = []
    
    # remove elements that do not contain new atomtypes
    for child in children:
        class_attr = [attr for attr in child.attrib.keys() if 'class' in attr]
        atom_idxs = []
        for attr in class_attr:
            try:
                atom_idx = int(split_classname(child.attrib[attr])[-1])
            except:    
                atom_idx = find_idx(root=opls_root, cls=child.attrib[attr])
            atom_idxs.append(atom_idx)
        if all([(idx < next_idx) for idx in atom_idxs]):
            children_to_remove.append(child)
            
    for ch in children_to_remove:
        parent.remove(ch)
    
    # remove elements that are duplicates
    to_keep = []
    to_remove = []
    for elem in parent.findall(child_name):
        duplicate = False
        for elem2keep in to_keep:
            if elements_equal(elem, elem2keep):
                duplicate = True
                break
        if duplicate:
            to_remove.append(elem)
        else:
            to_keep.append(elem)
            
    for elem2rmv in to_remove:
        parent.remove(elem2rmv)
    return


def add_atom(atom, atoms):
    '''
    Add info from Element from ElementTree
    with tag 'Atom' to a dict of atoms for
    which the keys are the atom IDs and the
    values are the elements
    '''
    element = split_classname(atom.get('name'))[0]
    ID = int(atom.get('type').split('_')[-1])-800
    atoms[ID] = element
    
    
def find_neighbors(atom_id, bonds):
    '''
    Given list of bonds, find ids of atoms
    that atom with `atom_id` is bonded to
    and return as list. List `bonds` should
    contain tuples
    of the form (atom_id_1, atom_id_2)
    '''
    neighbors = []
    for bond in bonds:
        if bond[0] == atom_id:
            neighbors.append(bond[1])
        elif bond[1] == atom_id:
            neighbors.append(bond[0])
    return neighbors


def find_atoms_and_bonds(residues):
    '''
    Given a 'Residues' Element in an ElementTree
    parsed from an oplsaa forcefield in xml
    format, create a dictionary with the atom info and
    a list with the bond info.
    
    Parameters
    ----------
    residues : Element
        contains data on the atoms
        and their bonds for the residue(s)
        
    Returns
    ----------
    atoms : dict
        mapping from atom index to element
    bonds : list
        contains tuples representing each
        bond of the form (atom_id_1, atom_id_2)
    '''
    atoms = dict()
    bonds = []
    for residue in residues:
        for elem in residue:
            if elem.tag == 'Atom':
                add_atom(elem, atoms)
            elif elem.tag == 'Bond':
                bonds.append((int(elem.get('to')), int(elem.get('from'))))
    return atoms, bonds


def find_H_to_remove(atoms, bonds):
    '''
    if more than one hydrogen is bonded to the
    same atom, all of the hydrogens except one
    should be deleted because they are equivilent
    and have the same atom type. This function
    finds all of the hydrogens that should be 
    deleted and returns their indices as keys
    in a dictionary, where the values are the
    indices of the equivilent hydrogens that
    are being kept.

    Parameters
    ----------
    atoms : dict
        mapping from atom index to element
    bonds : list
        contains tuples representing each
        bond of the form (atom_id_1, atom_id_2)

    Returns
    ----------
    to_remove : dict
        keys: index of hydrogen to remove
        value: index of equivilent hydrogen
            being kept 

    '''
    to_remove = dict()
    for atom_id, elem in atoms.items():
        if elem != 'H':
            h_neighbors = []
            for neighbor in find_neighbors(atom_id, bonds=bonds):
                if atoms[neighbor] == 'H':
                    h_neighbors.append(neighbor)
            if len(h_neighbors) > 1:
                kept = h_neighbors[0]
                for h_remove in h_neighbors[1:]:
                    to_remove[h_remove] = kept
    return to_remove


def map_atomtypes(atoms, to_remove, next_idx, starts_at=800):
    '''
    Create mapping from indices of atoms in forcefield
    file being added to new indices that account for the
    removal of duplicate hydrogens and atoms with an already
    existing atomtype in the forcefield, and that reflect the
    numbering in the forcefield being added to.
    
    Mapping of -1 means that atom should be removed.
    In this case, mapping4bonded_params specifies
    the index to be specified instead of the atom index
    (in bonded parameters), which is the index of an
    equivilent atomtype, either an already-existing one
    or one being added from the new forcefield.
    
    Parameters
    ----------
    atoms : dict
        mapping from atom index to element
    to_remove : dict
        keys: index of hydrogen to remove
        value: index of equivilent hydrogen
            being kept or index of already
            existing atomtype relative to
            next_idx
    next_idx : int
        the next index to be added to oplsaa.xml
        (or whatever file is being appended to)
    starts_at : int, default=800
        The index that the class numbering starts at
        in the xml doc passed in, which is 800 from
        xml documents from the LigParGen server
        
    Returns
    ----------
    mapping : dict
        keys are old indexes, values are indexes that
        should replace the old index, or -1 if the atom
        with the index should be removed
    mapping4bonded_params : dict
        similar to `mapping`, but hydrogens to be deleted
        map to the equivilent hydrogen that is being kept
        or the already existing atomtype. This mapping is
        used for bonds, angles, propers, and impropers because
        rather than deleting all bonded parameters involving
        an atom that is already typed, we want to simply change
        the indexing of bonded parameters to reflect the atomtypes
        being used.
        
    '''
    def find_subtract_by(atom):
        '''
        Find the `subtract_by` variable
        for an atom given the atom id
        '''
        if mapping.get(atom + starts_at) is not None:
            return -mapping.get(atom + starts_at) + atom + next_idx
        else:
            subtract_by = 0
            for h_to_remove, equiv_h in to_remove.items():
                if h_to_remove < atom:
                    subtract_by += 1
            return subtract_by
    mapping = dict()
    mapping4bonded_params = dict()
    for atom_id in list(atoms.keys()):
        subtract_by = 0
        for atom_to_remove, equiv_atom in to_remove.items():
            if atom_to_remove < atom_id:
                subtract_by += 1
            elif atom_to_remove == atom_id:
                mapping[atom_id + starts_at] = -1
                if equiv_atom >= 0:
                    mapping4bonded_params[atom_id + starts_at] = equiv_atom - find_subtract_by(equiv_atom) + next_idx
                else:
                    mapping4bonded_params[atom_id + starts_at] = equiv_atom + next_idx
                break
        else:
            map_from = atom_id + starts_at
            map_to = atom_id - subtract_by + next_idx
            mapping[map_from] = map_to
            mapping4bonded_params[map_from] = map_to
    return mapping, mapping4bonded_params


def elements_equal(e1, e2):
    '''
    Figure out if two Element objects
    in an ElementTree are equivilent.
    
    Source:
    https://stackoverflow.com/questions/7905380/testing-equivalence-of-xml-etree-elementtree
    
    Parameters
    ----------
    e1, e2 : Element
        elements to check for equivilence
    
    Returns
    ----------
    equivilence : bool
        True if elements are equivilent
        False if not
    '''
    if e1.tag != e2.tag: return False
    if e1.text != e2.text: return False
    if e1.tail != e2.tail: return False
    if e1.attrib != e2.attrib: return False
    if len(e1) != len(e2): return False
    return all(elements_equal(c1, c2) for c1, c2 in zip(e1, e2))


def main():
    # use the oplsaa.xml by default as the file to add to
    proj = signac.get_project()
    forcefield_filepath = pathlib.Path(
        proj.root_directory() + "/src/util/forcefield/oplsaa.xml"
    )
    
    # parse arguments to get files and ensure correct usage
    parser = argparse.ArgumentParser(description='Process input files.')
    parser.add_argument('-s', '--smiles', type=str, required=True,
                        dest='smiles_string',
                        help='SMILES string of input molecule')
    parser.add_argument('-a', '--add', type=str, required=True,
                        dest='file_to_add',
                        help='path to xml file to add')
    parser.add_argument('-t', '--to', type=str,
                        default=forcefield_filepath,
                        dest='file_to_add_to',
                        help='path to xml file to add to')

    args = parser.parse_args()
    smiles = vars(args)['smiles_string']
    file_to_add = vars(args)['file_to_add']
    file_to_add_to = vars(args)['file_to_add_to']
    
    # read and parse xml files
    with open(file_to_add, 'r') as f:
        new_oplsaa = ET.parse(f)
    with open(file_to_add_to, 'r') as f:
        oplsaa = ET.parse(f)
    
    root = oplsaa.getroot()
    new_root = new_oplsaa.getroot()
    
    # find which atoms in SMILES string
    # already have atomtype, and if so,
    # find their atomtype, given forcefield
    forcefield = foyer.Forcefield(forcefield_files=file_to_add_to)
    types = find_atomtypes(smiles, forcefield)
    
    # create dict of atoms and list of bonds in residue(s)
    residues = new_oplsaa.find("Residues")
    atoms, bonds = find_atoms_and_bonds(residues)
    new_root.remove(residues)
    
    # define next_idx as the number after the last index of the oplsaa file
    # being appended to
    existing_atomtypes = root.findall(".//Type")
    next_idx = int(existing_atomtypes[-1].get('name').split('_')[1]) + 1

    # find duplicate hydrogens to remove and create mapping
    to_remove = find_H_to_remove(atoms, bonds)
    # also remove atoms that are already atomtyped and map them
    # to the relative index of their already-existing atomtype
    for atom_idx, atom_type in types.items():
        if atom_type != 'opls_1010':
            to_remove[atom_idx] = int(atom_type.split('_')[-1]) - next_idx  
    mapping, mapping4bonded_params = map_atomtypes(atoms, to_remove, next_idx)
    
    # uncomment this block to test map_atomtypes function
#     print('to remove')
#     print(to_remove)
#     print('mapping')
#     print(mapping)
#     print('mapping4nonbonded_params')
#     print(mapping4nonbonded_params)
#     return

    # remove already typed atoms and duplicate hydrogens
    # from AtomTypes and NonbondedForce, and update indexing
    #
    # for bonded parameters, remove parameters if they are
    # already parameterized, and update indexing
    #
    forcefield_params = {'Type': 'AtomTypes',
                         'Bond': 'HarmonicBondForce',
                         'Angle': 'HarmonicAngleForce',
                         'Proper': 'PeriodicTorsionForce',
                         'Improper': 'PeriodicTorsionForce',
                         'Atom': 'NonbondedForce'}
    for child_name, parent_name in forcefield_params.items():
        if child_name in ['Type', 'Atom']:
            update_classnums(root=new_root, opls_root=root, parent_name=parent_name,
                             child_name=child_name, mapping=mapping)
        else:
            update_classnums(root=new_root, opls_root=root, parent_name=parent_name,
                             child_name=child_name, mapping=mapping4bonded_params)
            remove_duplicates(root=new_root, opls_root=root, parent_name=parent_name,
                              child_name=child_name, next_idx=next_idx)            
        
    # replace fourier parameters with RB parameters in torsions
    for proper in new_root.find("PeriodicTorsionForce").findall("Proper"):
        fi = list(proper.get('k'+str(i)) for i in range(1, 5))
        fi_converted = (float(f)*4.184/2.092 for f in fi)
        ci = fourier_coefs_to_RB_coefs(*fi_converted)
        for idx in range(6):
            proper.set('c'+str(idx), str(ci[idx]))
        for i in range(1, 5):
            for attr in ['periodicity', 'phase', 'k']:
                proper.attrib.pop(attr+str(i))
    
    # sort new atom types by the number in 'name' attribute
    # and append to the xml file to add to
    for elem_name, attr_name in [('Type', 'name'), ('Atom', 'type')]:
        parent = oplsaa.find(forcefield_params[elem_name])
        data = []
        for elem in new_oplsaa.findall('.//' + elem_name):
            attr = elem.get(attr_name)
            typenum = int(attr.split('_')[-1])
            data.append((typenum, elem))
        data.sort()
        parent.extend(ele[-1] for ele in data)
    
    # append bonded parameters to xml file
    for force in ['Bond', 'Angle', 'Proper', 'Improper']:
        parent_name = forcefield_params[force]
        if force == 'Proper':
            new_parent_name = 'RBTorsionForce'
        else:
            new_parent_name = parent_name
        parent = oplsaa.find(new_parent_name)
        parent.extend(elem for elem in new_oplsaa.findall('./{}/{}'.format(parent_name, force)))
        
    # write updated oplsaa forcefield to xml
    with open(file_to_add_to, 'wb') as f:
        oplsaa.write(f)

    
if __name__ == '__main__':
    main()
